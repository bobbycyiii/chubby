This is my understanding of my work for our proof
of the Gordon conjecture.

* Going through necklace manifolds

  N.B. We say ``going through'' necklace
  manifolds as opposed to merely ``enumerating''
  necklace manifolds because we never
  have all the manifolds in memory. The
  enumeration is in time, not in space.

** Definitions

*** Tetrahedra

    A tetrahedron has four vertices $\bar{0},\bar{1},\bar{2},\bar{3}$.
    It has six edges, one for every pair of vertices;
    and it has four faces, one opposite every vertex.
    We label faces by their opposite vertices.
    An orientation on it is a cyclic order on $\{\bar{0},\bar{1},\bar{2}\}$.
    The standard orientation is $\bar{0} \to \bar{1} \to \bar{2} (\to \bar{0})$.

*** Dipyramid

    The /\(m\)-dipyramid/ is the suspension
    of an \(m\)-gonal disc, if $m$ is a positive natural.
    We write $dp(m)$ for this polyhedral solid.

    One way to triangulate $dp(m)$ is to triangulate
    the $m$-gon and suspend the triangulation. However,
    there is a more efficient and natural triangulation.
    We posit a tetrahedron for every element of $\mathbf{Z}_m$
    and we posit that for every tetrahedron $t$,
    side $\bar{1}$ of $t$ is glued to side $\bar{3}$ of $t+1$
    via $(\bar{0},\bar{3},\bar{2})_t \mapsto (\bar{0},\bar{1},\bar{2})_{t+1}$.

    This triangulates a ball, and the triangulation induced
    on the boundary of the ball is combinatorially isomorphic
    to the boundary triangulation of an $m$-dipyramid.
   
*** Necklace manifold

    A face-pairing on convex polyhedra is /orienting/ 
    when all its face-pairs are orientation-reversing 
    homeomorphisms between their faces, where the faces'
    orientations come from the polyhedra's orientations.

    A /polar gluing/ is a complete, orienting face-pairing on
    a disjoint union of dipyramids such that the
    suspension points, or /poles/, of the dipyramids
    are sent to different vertex classes than are
    the \(m\)-gon vertices, or /laterals/.

    A /necklace gluing/ is a polar gluing on a single dipyramid.
    The underlying space of a necklace gluing is a /necklace manifold/.
    Necklace manifolds are special types of generalized
    one-relator manifold.
    
*** Necklace signature

    Begin with the above triangulation of an \(m\)-dipyramid,
    naming the tetrahedra by $\mathbf{Z}_m$. We label
    the faces by elements of $FF(m) = \mathbf{Z}_m \times \mathbf{Z}_2$
    as follows. Each tetrahedron $t$ has two remaining exterior 
    faces, opposite its vertices $\bar{0}$ and $\bar{2}$. We label
    the face opposite $\bar{0}$ we label $(t,0)$, and the
    other face we label $(t,1)$.

    We define $[N] = \{i:\mathbf{N}: 0\leq i < N\}$.
    We define a bijection $Y:FF(m)\to [2\cdot m]$ by
    $Y(t,s) = 2\cdot t + s$, with
    the usual injections of $\mathbf{Z}_x$ into $\mathbf{N}$.
    $FF(m)$ thereby inherits a total order from $[2\cdot m]$.
    (The order is not, however, invariant under the symmetries
    of $dp(m)$.)

    A necklace gluing on our particular triangulation
    of $dp(m)$ we can write as a set of 
    $m$ doubleton-sets of elements of \(FF(m)\), with no
    two pairs sharing an element. We can write
    this set canonically as a list of pairs, with
    the pairs in decreasing order and the list in
    decreasing order. (Decreasing and not increasing,
    as we suspect that formalizing this work will
    be easier if we use decreasing order.) Mapping
    $Y$ across the pairs of the list gives us
    an ordered list of $m$ disjoint strictly ordered
    pairs of elements of $[2\cdot m]$. That is a
    /numerical necklace signature./ Without mapping
    $Y$ we call it a /structural necklace signature/.

    We will simultaneously regard a necklace signature
    as a permutation---in fact, a fixed-point-free involution---on
    $[2\cdot m]$ (or on $FF(m)$ according as the signature
    is numerical or structured).

** Symmetries of dipyramid

   The symmetry group of $dp(m)$ we write as $DP(m)$.
   It is generated by the following elements.

   - Rotation $\rho_r$ around the edge between the poles
     by angle $r\cdot 2\cdot \pi/m$;
   - Reflection $\sigma$ across the \(m\)-gon's plane; and
   - Reflection $\kappa$ fixing the face $2\cdot m - 1$.

   With our identification $Y:FF(m) \to [2\cdot m]$ we can
   identify
   - $\rho_r(j) = j+2\cdot r$
   - $\sigma(j) = j+1-2\cdot(j\%2)$
   - $\kappa(j) = -j-2$.

   All the above operations (except $\%$) are modulo $2\cdot m$.

   We remind the reader that $x\%y$ is $x$ modulo
   $y$ as an element of $[y]$. For instance,
   $5\%3 = 2$, and $(-2)\%5 = 3$.

   The only symmetries with fixpoints are the
   identity and conjugates of $\kappa$. If $m$
   is even, then $\kappa$ has four fixpoints:
   $2\cdot m - 1, 2\cdot m-2, m+1, m$. If $m$
   is odd, then $\kappa$ has but two fixpoints, $2\cdot m -1$
   and $2\cdot m-2$.

   The action of $DP(m)$ on $[2\cdot m]$ naturally begets
   an action on necklace signatures (I guess because
   the map $neckl: Types \to Types$ given by
   $a \mapsto list (a,a)$ is a natural transformation
   or something like that).

   We discussed $DP(m)$ in the above depth because
   
   *Proposition:*

   Necklace gluings with numerical signatures in the
   same orbit of $DP(m)$ yield homeomorphic 3-manifolds
   upon gluing.

   (*End Proposition*)

   This should be quite clear; the room for error
   is in our definition of the action of $DP(m)$
   on $[2\cdot m]$. If the above proposition is
   untrue, change the action until it is true.
   
** Maximal signatures

   The total order on $[2\cdot m]$ naturally begets
   a total order on numerical necklace signatures. We
   can therefore single out representatives of orbits
   of necklace signatures under the action of $DP(m)$,
   viz. the maximal representatives.

   *Definition:*

   A /maximal/ necklace signature is one which is
   maximal in its $DP(m)$ orbit with respect to 
   the total order.

   (*End Definition*)

   We now put forth some properties of maximal signatures.
   (Recall that we identify signatures with involutions on
   the set of faces, i.e. on $[2\cdot m]$.

   Before embarking on our results about maximal signatures,
   we introduce some convenient notation.

   First, fix $m$. Let $M = 2\cdot m - 1$, the maximal
   face of $dp(m)$.

   For any face, there are two elements of $DP(m)$ 
   taking it to $M$. To determine formulas for these 
   it is convenient to first work with the structural 
   representation $FF(m)=\mathbf{Z}_m\times\mathbf{Z}_2$ 
   of faces. So let $(k,s) \in FF(m)$ be a face.
   Clearly we can take it to $M = (m-1,1)$ by rotating
   by $-(k+1)\cdot 2\cdot\pi/m$, then reflecting about
   the \(m\)-gon's plane if need be. That is, one
   map $\phi_{k,s}$ is defined as 
   $\phi_{k,s}(\ell,t) = (\ell-k-1,s+t+1)$.
   (It is orientation-preserving if $t=1$, and
   orientation-reversing if $t=0$.)

   Now, $Y(k,s) = 2\cdot k + s$, and the
   inverse $y$ is just $y(n) = (n/2, n\%2)$
   where $n/2$ is the integral quotient.
   
   Working it all out, letting $\Phi_n = Y\circ \phi_{y(n)} \circ y$,
   we get
   \[ \Phi_n(n') = 2\cdot(\frac{n'}{2}-\frac{n}{2}-1) + (n\%2) + (n'\%2) + 1.\]

   That's one map in $DP(m)$ taking $n$ to $M$.
   The other map is \(\kappa \circ \Phi_n\);
   $\kappa$ preserves $M$.

   *Proposition:*

   If $\eta$ is a maximal signature, 
   then $\eta(M) \geq m-1$.

   (*End Proposition*)

   *Proof:*

   Suppose $\eta$ is a signature and
   $\eta(M) < m-1$. Let
   $\eta' = \eta^\kappa = \kappa \circ \eta \circ \kappa$
   ($\kappa$ is an involution). Then
   $\eta'(M) = \kappa(\eta(\kappa(M))) = \kappa(\eta(M))$.
   Modulo $[2\cdot m]$ we have $\kappa(\eta(M)) = -\eta(M)-2$.
   Since $\eta(M) < m-1$, as integers $-\eta(M)-2 > -(m-1)-2 = -m-1$
   But of course $\eta(M) \geq 0$, so $-\eta(M)-2 \leq -2$.
   So $\kappa(\eta(M)) \in (-m-1,-2]$ as an integer; modulo
   $2\cdot m$, this is $(m-1,2\cdot m - 2]$, and
   so $\kappa(\eta(M)) > m-1$. Hence
   $\eta'(M) > \eta(M)$ contradicting maximality of $\eta$.

   (*End Proof*)

   *Proposition:*

   If $\eta$ is a maximal signature,
   then for every face $n \in [2\cdot m]$,
   $\eta^X(M) \leq \eta(M)$ for both
   $X \in \{\Phi_n, \sigma\circ\Phi_n\}$.

   (*End Proposition*)

   *Proof:*

   Note that
   \[ \bigcup_{n \in [2\cdot m]} \{\Phi_n, \sigma\circ\Phi_n\} = DP(m). \]

   So it will suffice to show that
   $\eta^g(M) \leq \eta(M)$ for all $g\in DP(m)$.

   But if we regard $\eta$ as a permutation, then
   the action of $DP(m)$ is by conjugation. So
   we are merely asking to show that $\eta(M)$
   is maximal among all $\eta^g(M)$ with $g \in DP(m)$.

   Suppose otherwise---suppose that for some $g \in DP(m)$,
   $\eta^g(M) > \eta(M)$. Then $\eta$ would have
   first pair $(M,\eta(M))$ in its list representation, 
   whereas $\eta^g$ would have first pair
   $(M,\eta^g(M)) > (M,\eta(M))$ in its representation.
   So the representation of $\eta^g$ would be greater
   than that of $\eta$. In other words, $\eta^g > \eta$,
   and $\eta$ would not be maximal, contrary to assumption.

   (*End Proof*)

** Enumerating

*** Introduction

    Before developing our ``going-through'' procedure,
    we define an enumeration scheme as a warmup. We will
    be enumerating maximal numerical necklace signatures.

    The naive way to do this is simply to enumerate
    /all/ numerical necklace signatures, then pick out
    the maximal ones. Immediately this raises the question
    of how to store all these signatures. The approach
    taken in \cite{GMM} is simply to put them all in a
    list. 

    This is unfortunate, since picking out an
    element from a list takes linear time. A better way
    to store the signatures is in a /prefix trie/.

    A /prefix trie on/ a totally ordered data type $A$
    is a way of representing a set of $A$-lists. It is
    a set of pairs of the form $(a, pt)$, where $a \in A$ and
    $pt$ is a prefix trie on $A$. We allow an empty set of pairs
    (that's the foundation for induction and recursion
    over prefix tries). We can represent this in
    =Python= as a =dict= with $a$ keys.

    A list $\ell$ of $A$ is said to be /in/ a
    prefix trie $pt$ when either $\ell = []$
    and $pt = \emptyset$, or $pt$ contains a
    pair $(a,pt')$ such that $a$ is the head
    of $\ell$ and the tail of $\ell$ is in $pt'$.

    We let $tt(m)$ denote the minimal prefix
    trie such that for all necklace signatures $\eta$
    on an \(m\)-dipyramid, $\eta$ is in $tt(m)$. 

    We let $mt(m)$ denote instead the minimal
    prefix trie such that for all /maximal/ necklace signatures
    $\eta$ on an \(m\)-dipyramid, $\eta$ is in $mt(m)$.

*** How the recursion goes

    One might imagine that one could construct
    $tt(m)$ by induction on $m$. That does not work.

    Instead, just as sometimes one needs to strengthen
    an inductive hypothesis, we instead need to strengthen
    our recursion. Instead of inducting on $m$, we
    introduce a more general function depending not
    just on $m$ but on other structures, and
    then we induct on those other structures.

**** Recursion for the naive approach

     The natural thing we imagine we would want to
     do is start off with all the faces, then choose
     some face $F \geq m-1$ to match with $M$. We
     remove $M$ and $F$ from the faces, and have some
     faces left. Next we take the maximal face left,
     and pick some remaining face to match it with.
     And so on and so forth.

     At each step in this imagined process we have
     to keep track of the pairs of faces we have taken away
     and the faces we have left. These sets of face-pairs
     and faces are the structures upon which we induct.

     If we have no faces left, then all the pairs of
     faces we've taken, in order, constitute a necklace
     signature.

     Otherwise, what do we do? The insight is that
     we think of the taken face-pairs as a /prefix/
     (hence the name ``prefix trie'' above). The
     more general function we will define will take
     in a prefix and a list of faces, and it will return
     a list of signatures beginning with the given
     prefix, and ending with pairs from the given list of faces.

     Now that we know what our more general function should
     do, it is easy to write it. The hard part was
     deciding how to soup up the recursion, how to
     generalize our =tt(m)= construction.

     #+NAME: naive_tt.py
     #+BEGIN_SRC python
       def tt(m):
           def with_prefix(prefix,leftover):
               if leftover == []:
                   return [prefix]
               else:
                   assert leftover[1:] != []
                   M = leftover[0]
                   tail = leftover[1:]
                   suffixes = []
                   for F in tail:
                       left = list(tail)
                       left.remove(F)
                       pref = prefix+[(M,F)]
                       suffixes += with_prefix(pref,left)
                   return suffixes
           faces = list(reversed(range(2*m)))
           return with_prefix([],faces)

     #+END_SRC

* Non-elementary embedding

  This is obviated by hyperbolicity. We may need it
  for the MOM-1.5 project though.
