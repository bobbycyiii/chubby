This is my understanding of my work for our proof
of the Gordon conjecture.

* TODO Enumerating necklace manifolds

** Definitions

*** Tetrahedra

    A tetrahedron has four vertices $\bar{0},\bar{1},\bar{2},\bar{3}$.
    It has six edges, one for every pair of vertices;
    and it has four faces, one opposite every vertex.
    We label faces by their opposite vertices.
    An orientation on it is a cyclic order on $\{\bar{0},\bar{1},\bar{2}\}$.
    The standard orientation is $\bar{0} \to \bar{1} \to \bar{2} (\to \bar{0})$.

*** Dipyramid

    The /\(m\)-dipyramid/ is the suspension
    of an \(m\)-gonal disc, if $m$ is a positive natural.
    We write $dp(m)$ for this polyhedral solid.

    One way to triangulate $dp(m)$ is to triangulate
    the $m$-gon and suspend the triangulation. However,
    there is a more efficient and natural triangulation.
    We posit a tetrahedron for every element of $\mathbf{Z}_m$
    and we posit that for every tetrahedron $t$,
    side $\bar{1}$ of $t$ is glued to side $\bar{3}$ of $t+1$
    via $(\bar{0},\bar{3},\bar{2})_t \mapsto (\bar{0},\bar{1},\bar{2})_{t+1}$.

    This triangulates a ball, and the triangulation induced
    on the boundary of the ball is combinatorially isomorphic
    to the boundary triangulation of an $m$-dipyramid.
   
*** Necklace manifold

    A face-pairing on convex polyhedra is /orienting/ 
    when all its face-pairs are orientation-reversing 
    homeomorphisms between their faces, where the faces'
    orientations come from the polyhedra's orientations.

    A /polar gluing/ is a complete, orienting face-pairing on
    a disjoint union of dipyramids such that the
    suspension points, or /poles/, of the dipyramids
    are sent to different vertex classes than are
    the \(m\)-gon vertices, or /laterals/.

    A /necklace gluing/ is a polar gluing on a single dipyramid.
    The underlying space of a necklace gluing is a /necklace manifold/.
    Necklace manifolds are special types of generalized
    one-relator manifold.
    
*** Necklace signature

    Begin with the above triangulation of an \(m\)-dipyramid,
    naming the tetrahedra by $\mathbf{Z}_m$. We label
    the faces by elements of $FF(m) = \mathbf{Z}_m \times \mathbf{Z}_2$
    as follows. Each tetrahedron $t$ has two remaining exterior 
    faces, opposite its vertices $\bar{0}$ and $\bar{2}$. We label
    the face opposite $\bar{0}$ we label $(t,0)$, and the
    other face we label $(t,1)$.

    We define $[N] = \{i:\mathbf{N}: 0\leq i < N\}$.
    We define a bijection $Y:FF(m)\to [2\cdot m]$ by
    $Y(t,s) = 2\cdot t + s$, with
    the usual injections of $\mathbf{Z}_x$ into $\mathbf{N}$.
    $FF(m)$ thereby inherits a total order from $[2\cdot m]$.
    (The order is not, however, invariant under the symmetries
    of $dp(m)$.)

    A necklace gluing on our particular triangulation
    of $dp(m)$ we can write as a set of 
    $m$ doubleton-sets of elements of \(FF(m)\), with no
    two pairs sharing an element. We can write
    this set canonically as a list of pairs, with
    the pairs in decreasing order and the list in
    decreasing order. (Decreasing and not increasing,
    as we suspect that formalizing this work will
    be easier if we use decreasing order.) Mapping
    $Y$ across the pairs of the list gives us
    an ordered list of $m$ disjoint strictly ordered
    pairs of elements of $[2\cdot m]$. That is a
    /numerical necklace signature./ Without mapping
    $Y$ we call it a /structural necklace signature/.

    We will simultaneously regard a necklace signature
    as a permutation---in fact, a fixed-point-free involution---on
    $[2\cdot m]$ (or on $FF(m)$ according as the signature
    is numerical or structured).

** Symmetries of dipyramid

   The symmetry group of $dp(m)$ we write as $DP(m)$.
   It is generated by the following elements.

   - Rotation $\rho_r$ around the edge between the poles
     by angle $r\cdot 2\cdot \pi/m$;
   - Reflection $\sigma$ across the \(m\)-gon's plane; and
   - Reflection $\kappa$ fixing the face $2\cdot m - 1$.

   With our identification $Y:FF(m) \to [2\cdot m]$ we can
   identify
   - $\rho_r(j) = j+2\cdot r$
   - $\sigma(j) = j+1-2\cdot(j\%2)$
   - $\kappa(j) = -j-2$.

   All the above operations (except $\%$) are modulo $2\cdot m$.

   We remind the reader that $x\%y$ is $x$ modulo
   $y$ as an element of $[y]$. For instance,
   $5\%3 = 2$, and $(-2)\%5 = 3$.

   The only symmetries with fixpoints are the
   identity and conjugates of $\kappa$. If $m$
   is even, then $\kappa$ has four fixpoints:
   $2\cdot m - 1, 2\cdot m-2, m+1, m$. If $m$
   is odd, then $\kappa$ has but two fixpoints, $2\cdot m -1$
   and $2\cdot m-2$.

   The action of $DP(m)$ on $[2\cdot m]$ naturally begets
   an action on necklace signatures (I guess because
   the map $neckl: Types \to Types$ given by
   $a \mapsto list (a,a)$ is a natural transformation
   or something like that).

   We discussed $DP(m)$ in the above depth because
   
   *Proposition:*

   Necklace gluings with numerical signatures in the
   same orbit of $DP(m)$ yield homeomorphic 3-manifolds
   upon gluing.

   (*End Proposition*)

   This should be quite clear; the room for error
   is in our definition of the action of $DP(m)$
   on $[2\cdot m]$. If the above proposition is
   untrue, change the action until it is true.
   
** Maximal signatures

   The total order on $[2\cdot m]$ naturally begets
   a total order on numerical necklace signatures. We
   can therefore single out representatives of orbits
   of necklace signatures under the action of $DP(m)$,
   viz. the maximal representatives.

   *Definition:*

   A /maximal/ necklace signature is one which is
   maximal in its $DP(m)$ orbit with respect to 
   the total order.

   (*End Definition*)

   We now put forth some properties of maximal signatures.
   (Recall that we identify signatures with involutions on
   the set of faces, i.e. on $[2\cdot m]$.

   Before embarking on our results about maximal signatures,
   we introduce some convenient notation.

   First, fix $m$. Let $M = 2\cdot m - 1$, the maximal
   face of $dp(m)$.

   For any face, there are two elements of $DP(m)$ 
   taking it to $M$. To determine formulas for these 
   it is convenient to first work with the structural 
   representation $FF(m)=\mathbf{Z}_m\times\mathbf{Z}_2$ 
   of faces. So let $(k,s) \in FF(m)$ be a face.
   Clearly we can take it to $M = (m-1,1)$ by rotating
   by $-(k+1)\cdot 2\cdot\pi/m$, then reflecting about
   the \(m\)-gon's plane if need be. That is, one
   map $\phi_{k,s}$ is defined as 
   $\phi_{k,s}(\ell,t) = (\ell-k-1,s+t+1)$.
   (It is orientation-preserving if $t=1$, and
   orientation-reversing if $t=0$.)

   Now, $Y(k,s) = 2\cdot k + s$, and the
   inverse $y$ is just $y(n) = (n/2, n\%2)$
   where $n/2$ is the integral quotient.
   
   Working it all out, letting $\Phi_n = Y\circ \phi_{y(n)} \circ y$,
   we get
   \[ \Phi_n(n') = 2\cdot(\frac{n'}{2}-\frac{n}{2}-1) + (n\%2) + (n'\%2) + 1.\]

   That's one map in $DP(m)$ taking $n$ to $M$.
   The other map is \(\kappa \circ \Phi_n\);
   $\kappa$ preserves $M$.

   *Proposition:*

   If $\eta$ is a maximal signature, 
   then $\eta(M) \geq m-1$.

   (*End Proposition*)

   *Proof:*

   Suppose $\eta$ is a signature and
   $\eta(M) < m-1$. Let
   $\eta' = \eta^\kappa = \kappa \circ \eta \circ \kappa$
   ($\kappa$ is an involution). Then
   $\eta'(M) = \kappa(\eta(\kappa(M))) = \kappa(\eta(M))$.
   Modulo $[2\cdot m]$ we have $\kappa(\eta(M)) = -\eta(M)-2$.
   Since $\eta(M) < m-1$, as integers $-\eta(M)-2 > -(m-1)-2 = -m-1$
   But of course $\eta(M) \geq 0$, so $-\eta(M)-2 \leq -2$.
   So $\kappa(\eta(M)) \in (-m-1,-2]$ as an integer; modulo
   $2\cdot m$, this is $(m-1,2\cdot m - 2]$, and
   so $\kappa(\eta(M)) > m-1$. Hence
   $\eta'(M) > \eta(M)$ contradicting maximality of $\eta$.

   (*End Proof*)

   *Proposition:*

   If $\eta$ is a maximal signature,
   then for every face $n \in [2\cdot m]$,
   $\eta^X(M) \leq \eta(M)$ for both
   $X \in \{\Phi_n, \sigma\circ\Phi_n\}$.

   (*End Proposition*)

   *Proof:*

   Note that
   \[ \bigcup_{n \in [2\cdot m]} \{\Phi_n, \sigma\circ\Phi_n\} = DP(m). \]

   So it will suffice to show that
   $\eta^g(M) \leq \eta(M)$ for all $g\in DP(m)$.

   But if we regard $\eta$ as a permutation, then
   the action of $DP(m)$ is by conjugation. So
   we are merely asking to show that $\eta(M)$
   is maximal among all $\eta^g(M)$ with $g \in DP(m)$.

   Suppose otherwise---suppose that for some $g \in DP(m)$,
   $\eta^g(M) > \eta(M)$. Then $\eta$ would have
   first pair $(M,\eta(M))$ in its list representation, 
   whereas $\eta^g$ would have first pair
   $(M,\eta^g(M)) > (M,\eta(M))$ in its representation.
   So the representation of $\eta^g$ would be greater
   than that of $\eta$. In other words, $\eta^g > \eta$,
   and $\eta$ would not be maximal, contrary to assumption.

   (*End Proof*)

** Enumerating

    We will be enumerating maximal numerical necklace signatures.

*** Introduction
     The naive way to do this is simply to enumerate
     /all/ numerical necklace signatures, then pick out
     the maximal ones. Immediately this raises the question
     of how to store all these signatures. The approach
     taken in \cite{GMM} is simply to put them all in a
     list. 

     This is unfortunate, since picking out an
     element from a list takes linear time. A better way
     to store the signatures is in a /prefix trie/.

     A /prefix trie on/ a totally ordered data type $A$
     is a way of representing a set of $A$-lists. It is
     a set of pairs of the form $(a, pt)$, where $a \in A$ and
     $pt$ is a prefix trie on $A$. We allow an empty set of pairs
     (that's the foundation for induction and recursion
     over prefix tries). We can represent this in
     =Python= as a =dict= with $a$ keys.

     A list $\ell$ of $A$ is said to be /in/ a
     prefix trie $pt$ when either $\ell = []$
     and $pt = \emptyset$, or $pt$ contains a
     pair $(a,pt')$ such that $a$ is the head
     of $\ell$ and the tail of $\ell$ is in $pt'$.

     We let $tt(m)$ denote the minimal prefix
     trie such that for all necklace signatures $\eta$
     on an \(m\)-dipyramid, $\eta$ is in $tt(m)$. 

     We let $mt(m)$ denote instead the minimal
     prefix trie such that for all /maximal/ necklace signatures
     $\eta$ on an \(m\)-dipyramid, $\eta$ is in $mt(m)$.

*** Implementing symmetries

    Regardless of what we end up doing, we are going
    to need to implement the dipyramidal symmetries
    described above. That's quite simple.

    #+NAME: dipyramidSymmetries
    #+BEGIN_SRC python
      def rot(m,r,j):
          return (j + 2*r) % (2*m)

      def sigma(j):
          return j + 1 - 2 * (j%2)

      def kappa(m,j):
          return (-j-2) % (2*m)

    #+END_SRC

    We must define the action of these
    symmetries on signatures.

    #+NAME: dipyrOnSignatures
    #+BEGIN_SRC python
      def partialActSig(f,sg):
          def pairAct(p):
              return (f(p[0]),f(p[1]))
          return map(lambda p: pairAct(p), sg)

      def normalize(partsg):
          def sortPair(p):
              if p[0] < p[1]:
                  return (p[1],p[0])
              return p
          sg = list(partsg)
          sg = map(sortPair, sg)
          sg.sort()
          sg.reverse()
          return sg

      def actSig(f,sg):
          return normalize(partialActSig(f,sg))

    #+END_SRC

    Python already defines the total
    order properly, so we just need to
    define maximality. To do that we
    first need to define the /orbit/
    of a signature under the symmetries.

    #+NAME: orbitSig
    #+BEGIN_SRC python :tangle
      def orbit(m,sg):
          z2z2 = [lambda j:j,
                  sigma,
                  lambda j:kappa(m,j),
                  lambda j:sigma(kappa(m,j))]
          rs = range(m)
          orbit = set()
          for r in rs:
              rt = lambda j: rot(m,r,j)
              for flp in z2z2:
                  f = lambda j: rt(flp(j))
                  orbit.add(tuple(actSig(f,sg)))
          orbit = list(orbit)
          orbit = map(list, orbit)
          return orbit

    #+END_SRC

    Now we can define maximality.

    #+NAME: maximality
    #+BEGIN_SRC python
      def maximal(m,sg):
          orb = orbit(m,sg)
          for s in orb:
              if s > sg:
                  return False
          return True

    #+END_SRC

    #+NAME: dipyramidAction
    #+BEGIN_SRC python :noweb yes :tangle dipyrAction.py
      <<dipyramidSymmetries>>
      <<dipyrOnSignatures>>
      <<orbitSig>>
      <<maximality>>
    #+END_SRC

*** Naive enumeration approach

    One might imagine that one could construct
    $tt(m)$ by induction on $m$. That does not work.

    Instead, just as sometimes one needs to strengthen
    an inductive hypothesis, we instead need to strengthen
    our recursion. Instead of inducting on $m$, we
    introduce more general functions depending not
    just on $m$ but on other structures, and
    then we induct on those other structures.

**** Naive recursion for the naive approach

     The natural thing we imagine we would want to
     do is start off with all the faces, then choose
     some face $F \geq m-1$ to match with $M$. We
     remove $M$ and $F$ from the faces, and have some
     faces left. Next we take the maximal face left,
     and pick some remaining face to match it with.
     And so on and so forth.

     At each step in this imagined process we have
     to keep track of the pairs of faces we have taken away
     and the faces we have left. These sets of face-pairs
     and faces are the structures upon which we induct.

     If we have no faces left, then all the pairs of
     faces we've taken, in order, constitute a necklace
     signature.

     Otherwise, what do we do? The insight is that
     we think of the taken face-pairs as a /prefix/
     (hence the name ``prefix trie'' above). The
     more general function we will define will take
     in a prefix and a list of faces, and it will return
     a list of signatures beginning with the given
     prefix, and ending with pairs from the given list of faces.

     Now that we know what our more general function should
     do, it is easy to write it. The hard part was
     deciding how to soup up the recursion, how to
     generalize our =tt(m)= construction.

     #+NAME: naive_tt
     #+BEGIN_SRC python
       def tt(m):
           def with_prefix(prefix,leftover):
               if leftover == []:
                   return [prefix]
               else:
                   assert leftover[1:] != []
                   M = leftover[0]
                   tail = leftover[1:]
                   suffixes = []
                   for F in tail:
                       left = list(tail)
                       left.remove(F)
                       pref = prefix+[(M,F)]
                       suffixes += with_prefix(pref,left)
                   return suffixes
           faces = range(2*m)
           faces.reverse()
           return with_prefix([],faces)

     #+END_SRC

**** A less naive and easier approach

     If we return a prefix trie, then the program actually
     gets /easier/. But if we use a trie, then we should
     also make sure we know what we mean when we say a
     list is /in/ a trie, as described above. So we define
     that here as well. For good measure we also define
     a routine that enumerates all the lists in a trie.

     #+NAME: withTries
     #+BEGIN_SRC python :tangle
       def ttTrie(m):
	   def fromLeft(leftover):
	       if leftover == []:
		   return {}
	       M = leftover[0]
	       tail = leftover[1:]
	       assert tail != []
	       triePairs = {}
	       for F in tail:
		   left = list(tail)
		   left.remove(F)
		   a = (M,F)
		   trie = fromLeft(left)
		   triePairs[a] = trie
	       return triePairs
	   faces = range(2*m)
	   faces.reverse()
	   return fromLeft(faces)

       def isIn(list,trie):
	   if trie == {}:
	       return list == []
	   elif list == []:
	       return false
	   head = list[0]
	   tail = list[1:]
	   if head in trie:
	       # That is, if head is
	       # one of the keys at the
	       # top level of the trie.
	       return isIn(tail,trie[head])
	   return False

       def listElements(trie):
	   elts = []
	   if trie == {}:
	       return [[]]
	   for key in trie:
	       afterKey = listElements(trie[key])
	       withKey = map(lambda l:[key] + l, afterKey)
	       elts += withKey
	   return elts

     #+END_SRC

     We note that =listElements= doesn't typically list
     the elements in increasing or decreasing order.

     We can also define how to insert and remove
     lists from tries. These operations don't return
     new tries, but mutate a given trie. Our insertion
     inserts a list, but there is no restriction on the
     length of that list. Neither is their such a restriction
     on the delete operation, which prunes entire branches
     with a common prefix.

     #+NAME: trieTrimming
     #+BEGIN_SRC python
       def mutInsert(l,trie):
           if l == []:
               return None
           head = l[0]
           tail = l[1:]
           if head in trie:
               mutInsert(tail,trie[head])
           else:
               newt = {}
               mutInsert(tail,newt)
               trie[head] = newt

       def mutDelete(pref,trie):
           if pref == []:
               trie.clear()
               return True
           elif not pref[0] in trie:
               return False
           else:
               head = pref[0]
               tail = pref[1:]
               deleted = mutDelete(tail, trie[head])
               if trie[head] == {} and deleted:
                   trie.pop(head)
               return deleted
           
     #+END_SRC

     Concluding the naive approach, we remove orbits
     from the trie, and record the maximum in each orbit.

     #+NAME: maximalSignaturesNaive
     #+BEGIN_SRC python
       def popList(trie):
           if trie == {}:
               return []
           (head,after) = trie.popitem()
           l = [head] + popList(after)
           if after != {}:
               trie[head] = after
           return l

       def maximumSignatures(m):
           sigs = {}
           ttt = ttTrie(m)
           while ttt != {}:
               sg = popList(ttt)
               orb = orbit(m,sg)
               orb.remove(sg)
               for s in orb:
                   mutDelete(s,ttt)
                   if s > sg:
                       sg = s
               mutInsert(sg,sigs)
           return sigs

     #+END_SRC

**** The lot
     #+NAME: naiveApproach
     #+BEGIN_SRC python :noweb yes :tangle naive.py
       from dipyrAction import *
       <<naive_tt>>
       <<withTries>>
       <<trieTrimming>>
       <<maximalSignaturesNaive>>

     #+END_SRC

**** Naive approach fails past 8

     The naive approach detailed above fails
     to work on my old laptop for necklace 
     gluings on \(m\)-dipyramids for $m > 8$.
     The memory requirements are too onerous.
     The trie structure =ttTrie(8)= uses
     approximately 1.6 gibibytes; my laptop
     has about 8 gibibytes of memory.

     Nevertheless, this works fine for
     necklace gluings on 7-dipyramids and smaller, 
     even on a Raspberry Pi. 

*** More clever enumeration

    A more clever enumeration scheme will, insofar
    as is possible, avoid enumerating non-maximal
    signatures. To accomplish such a scheme we use
    the results above on maximal signatures.

    We will leave this until we have need of it.

** Going through

   If all we wish to do is go through all
   maximal signatures and do something for each
   one---for instance, determine whether or not
   it glues up to a cusped hyperbolic 3-manifold---then
   we need not first put them all signatures or
   even all maximal signatures in one place. Instead,
   we can make a procedure whose call-structure is
   the same as the call-structure of our enumeration---such
   a procedure would be something like a prefix-tree
   hylomorphism, except a stateful procedure instead
   of some effect-free function.

   If we wished to investigate necklaces on 9-dipyramids
   this would likely be convenient to use. Again, though,
   as it is the above naive approach works just fine
   for 7-dipyramids and below. So we will abandon this idea
   and move on to the next part of the project.


* TODO Determining nonelementary embedding of necklaces

** Triangulating necklaces from signatures

   This is pretty much old hat by now. Refer to the
   definitions above. What remains for us to do is
   explain how $[2\cdot m]$ maps onto the faces of
   the actual tetrahedra in our given triangulation
   of the \(m\)-dipyramid. Here is that triangulation.

   #+NAME: dipyrTriangulation
   #+BEGIN_SRC python
     from regina import Triangulation3, Perm4
     def mutAddDipyr(m,mfld):
         S = mfld.size()
         for i in range(m):
             t = mfld.newSimplex()
             assert t.index() == S + i
         for i in range(m):
             t = mfld.simplex(S+i)
             tp = mfld.simplex(S+((i+1)%m))
             t.join(3,tp,Perm4(1,3))

             
   #+END_SRC

   The tetrahedron indexed by $j \in [m]$ has
   faces labelled $2\cdot j$ and $2\cdot j + 1$.
   We regard the even labelled face as opposite
   the vertex $\bar{0}$ and the odd labelled
   face as opposite the vertex $\bar{2}$.

   Going backwards then, the index of the tetrahedron
   of a face $f \in [2\cdot m]$ is $f/2$, the
   integral quotient; and we can determine which
   exterior face it is by checking the parity of $f$.
   In fact, if $x = 2\cdot (f\%2)$ then the face
   is opposite the vertex $\bar{x}$ in its tetrahedron.

   #+NAME: necklaceTriangulation
   #+BEGIN_SRC python
     def necklaceManifold(sg):
         mfld = Triangulation3()
         m = len(sg)
         mutAddDipyr(m,mfld)
         for p in sg:
             (f0,f1) = p
             t = mfld.simplex(f0/2)
             face = 2*(f0%2)
             tp = mfld.simplex(f1/2)
             if f0%2 == f1%2:
                 phi = Perm4(1,3)
             else:
                 phi = Perm4(0,2)
             t.join(face,tp,phi)
         return mfld

    #+END_SRC

   #+NAME: necklaces
   #+BEGIN_SRC python :noweb yes :tangle necklaces.py
     <<dipyrTriangulation>>
     <<necklaceTriangulation>>
        
   #+END_SRC
** Determining nonelementary embedding

   There should be an algorithm to determine
   whether a given cusped 3-manifold embeds
   non-elementarily in a cusped hyperbolic 3-manifold

   We do not need such an algorithm for this
   project, as we have proven that all such
   manifolds we require are hyperbolic. I may
   pursue such an algorithm elsewhere.

** TODO Determining hyperbolicity

   To determine whether or not a 3-manifold
   is cusped hyperbolic, we simply determine whether
   or not it has appropriate vertex links, and whether
   or not it has any faults.

   #+NAME: cusped
   #+BEGIN_SRC python
     def cusped(mfld):
         cpts = mfld.boundaryComponents()
         for cpt in cpts:
             dt = cpt.build()
             if dt.eulerCharTri() != 0:
                 return False
         return True

   #+END_SRC

   #+NAME: faults
   #+BEGIN_SRC python
     def findSphereFault(mfld):
         
   #+END_SRC

* TODO Bounding the number of exceptional fillings

** A worry and its resolution

   One worry about determining exception fillings
   vaguely enters the mind. In spelling it out, one
   immediately sees how to dismiss it.

   That worry is that we are going to be
   trying to tell whether or not /closed/ 3-manifolds
   are hyperbolic. Whereas HIKMOT (see \cite{HIKMOT})
   can verify the hyperbolicity of closed hyperbolic
   3-manifolds, it cannot disprove hyperbolicity.
   Worse, for a closed 3-manifold we have no good,
   easily implementable certificate of its 
   nonhyperbolicity (unless it is Haken).

   This concern vanishes when one remembers our
   ultimate goal: not determining precisely which
   fillings are exceptional, but merely getting
   an upper bound on the number of such fillings.
   If we can show that all fillings but $k < 10$
   of a one-cusped 3-manifold are hyperbolic, then
   we are in the clear for that 3-manifold.


** 
